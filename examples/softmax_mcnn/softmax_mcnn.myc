/*
	we rapresent numbers as binary vector of size 10 (0-9)
	the image is big 256x256 grey-scale pixels, so...
	
		first layer has 10 neurons with how many weights?
		28*28 = 784 weights
	

*/

@import "lib/c/stdio.myc"
@import "lib/memory.myc"

//  ssize_t read(int fd, void *buf, size_t count);
function read(:fd int32, :buf *?, :count uint64) uint64 external;

// int open(const char *pathname, int flags, mode_t mode);
function open(:pathname *uint8, :flags int32, :mode uint32) int32 external;

function flip32(:x uint32) uint32{
	:flipped uint32 = 0;
	
	flipped |= (x & (0xFF << 0 )) << 24;
	flipped |= (x & (0xFF << 8 )) << 8 ;
	flipped |= (x & (0xFF << 16)) >> 8 ;
	flipped |= (x & (0xFF << 24)) >> 24;

	return flipped;
}

function read_dataset_image(:filename string) [][28][28]uint8 {
	// open file read-only
	:fd int32 = open(filename.data, 0, 0);
	if fd < 0 {
		printf("error: could not opend file `%s`!".data, filename.data);
		return;
	}

	// magic value
	:magic_value uint32;
	:n uint64 = read(fd, &magic_value, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	magic_value = flip32(magic_value);
	printf("magic number: %x\n".data, magic_value);

	// number of images
	:number_of_images uint32;
	n = read(fd, &number_of_images, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	number_of_images = flip32(number_of_images);
	printf("number of images in set: %d\n".data, number_of_images);

	// number of rows
	:number_of_rows uint32;
	n = read(fd, &number_of_rows, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	number_of_rows = flip32(number_of_rows);
	printf("number of rows in set: %d\n".data, number_of_rows);
	
	// number of columns
	:number_of_columns uint32;
	n = read(fd, &number_of_columns, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	number_of_columns = flip32(number_of_columns);
	printf("number of columns in set: %d\n".data, number_of_columns);

	:number_of_pixels uint32 = number_of_images * number_of_rows * number_of_columns;
	printf("number of pixels in set: %d\n".data, number_of_pixels);

	:images [][28][28]uint8 = allocate([uint64]number_of_pixels);
	for(:i uint32 = 0; i < number_of_images; i++) {
		n = read(fd, images[i].data, ([uint64]number_of_rows * [uint64]number_of_columns));
		if n < ([uint64]number_of_rows * [uint64]number_of_columns) {
			printf("error: could not read file in memory!\n".data);
			return;
		}
	}
	
	return images;
}

function read_dataset_label(:filename string) []uint8 {
	// open file read-only
	:fd int32 = open(filename.data, 0, 0);
	if fd < 0 {
		printf("error: could not opend file `%s`!".data, filename.data);
		return;
	}

	// magic value
	:magic_value uint32;
	:n uint64 = read(fd, &magic_value, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	magic_value = flip32(magic_value);
	printf("magic number: %x\n".data, magic_value);

	// number of labels
	:number_of_labels uint32;
	n = read(fd, &number_of_labels, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	number_of_labels = flip32(number_of_labels);
	printf("number of labels in set: %d\n".data, number_of_labels);

	:labels []uint8 = allocate([uint64]number_of_labels);
	n = read(fd, labels.data, [uint64]number_of_labels);
	if n < [uint64]number_of_labels {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	
	return labels;
}

/*
function matmul(:a [28][28]uint32, :b [28][28]uint32) [28][28]uint32 {
	:ah uint64 = a.len;
	if ah <= 0 {
		return;
	}
	:aw uint64 = a[0].len;
	if aw <= 0 {
		return;
	}
	
	:bh uint64 = b.len;
	if bh <= 0 {
		return;
	}
	:bw uint64 = b[0].len;
	if bw <= 0 {
		return;
	}

	if aw != bh {
		return;
	}

	:c [28][28]uint32; 

	for(:i int32 = 0; i < [int32]ah; i++) {
		for(:j int32 = 0; j < [int32]aw; j++) {
			for(:k int32 = 0; k < [int32]aw; k++) {
				c[i][j] += a[k][i] * b[k][j];
			}
		}
	}

	return c;
} 
*/

function vecmul(:a []f32, :b []f32) f32 {
	if a.len != b.len {
		return;
	}

	:res f32;
	for(:i int32 = 0; i < [int32]a.len; i++) {
		res += a[i] * b[i];
	}

	res
}

struct Neuron {
	:weights []f32;
	:bias 	   f32;
}

function nn() [][10]Neuron {
	:network [][10]Neuron = allocate(2 * 10 * 20);

	printf("net layers: %u\n".data, network.len);

	// first layer 784*10
	for(:i uint64 = 0; i < network[0].len; i++) {
		network[0][i].weights = allocate(784 * 4);
	}
	printf("net[0] weights: %u\n".data, network[0][0].weights.len);

	// second layer 10*10
	for(:i uint64 = 0; i < network[1].len; i++) {
		network[1][i].weights = allocate(10 * 4);
	}
	printf("net[1] weights: %u\n".data, network[1][0].weights.len);

	return network;
}

/*
function exp(:x f32) f32 {
	:e f32 = 2.71828;
	:res f32 = 1.0;

	// 3 is a very good approximation of e
	for(:i int32 = 0; i < x; i++) {
		printf("res : %f\n".data, [f64]res);
		res *= e;
	}
	for(:i int32 = 0; i > x; i--) {
		printf("res : %f\n".data, [f64]res);
		res /= e;
	}

	res
}
*/

//float expf(float x);
function expf(:x f32) f32 external;

//float logf(float x);
function logf(:x f32) f32 external;

function logistic(:x f32) f32 {
	printf("x : %f\n".data, [f64]x);

	:nominator f32 = 1.0;
	:denominator f32 = 1.0 + expf(-x);
	printf("nominator: %g\n".data, [f64]nominator);
	printf("denominator: %g\n".data, [f64]denominator);

	:sigmoid f32 = nominator / denominator;
	return sigmoid;
}

function softmax(:z []f32, :i int32) f32 {
	:denominator f32 = 0.0;	
	for(:j uint64 = 0; j < z.len; j++) {
		printf("x[%u] = %f\n".data, j, [f64]z[j]);
		denominator += z[j];
	}

	printf("nominator: %f\n".data, [f64]z[i]);
	printf("denominator: %f\n".data, [f64]denominator);
	
	z[i] / denominator
}

function forward(:net [][10]Neuron, :x [784]f32) [10]f32 {
	// ** input layer **
	printf("input layer (sigmoid):\n".data);
	:a1 [10]f32;
	for(:n int32 = 0; n < [int32]net[0].len; n++) {
		printf("weights:\n".data);
		for(:r uint32 = 0; r < 28; r++) {
			for(:c uint32 = 0; c < 28; c++) {
				printf("%f ".data, [f64]net[0][n].weights[r * 28 + c]);
			}
			printf("\n".data);
		}

		printf("input:\n".data);
		for(:r uint32 = 0; r < 28; r++) {
			for(:c uint32 = 0; c < 28; c++) {
				printf("%f ".data, [f64]x[r * 28 + c]);
			}
			printf("\n".data);
		}

		printf("bias: %f\n".data, [f64]net[0][n].bias);

		// ** linear part **
		// z = wt * x + b
		:z f32 = vecmul(net[0][n].weights, x);

		z += net[0][n].bias;

		// ** activation function **
		:l f32 = logistic(z);
		a1[n] = l;
		printf("logistic: %f\n".data, [f64]a1[n]);
	}

	
	// ** output layer **
	printf("output layer (softmax):\n".data);
	:z2 [10]f32;
	for(:n int32 = 0; n < [int32]net[1].len; n++) {
		printf("weights:\n".data);
		for(:r uint32 = 0; r < 10; r++) {
			printf("%f ".data, [f64]net[1][n].weights[r]);
		}
		putchar('\n');

		printf("input:\n".data);
		for(:r uint32 = 0; r < 10; r++) {
			printf("%f ".data, [f64]a1[r]);
		}
		putchar('\n');

		printf("bias: %f\n".data, [f64]net[1][n].bias);

		// ** linear part **
		// z = wt * x + b
		:z f32 = vecmul(net[1][n].weights, a1);

		z += net[1][n].bias;

		z2[n] = z;
	}
		
	// softmax activation function 
	:a2 [10]f32;
	for(:n int32 = 0; n < [int32]net[1].len; n++) {
		a2[n] = softmax(z2, n);
		printf("softmax: %f\n".data, [f64]a2[n]);
	}

	a2
}

function loss(:q f32, :p f32) f32 {
	-(p * logf(q))
}

// partial derivative of loss with respect to q 
function der_loss_q(:q f32, :p f32) f32 {
	p / q
}

function cost(:q [10]f32, :p [10]f32) f32 {
	for(:n int32 = 0; n < [int32]q.len; n++) {
		printf("q[%u]: %f; p[%u]: %f\n".data, n, [f64]q[n], n, [f64]p[n]);
	}

	:result f32;
	for(:i uint64 = 0; i < q.len; i++) {
		result += loss(q[i], p[i]);
	}
	result / [f32]q.len
}

function der_cost_q(:q [10]f32, :p [10]f32) f32 {
	for(:n int32 = 0; n < [int32]q.len; n++) {
		printf("q[%u]: %f; p[%u]: %f\n".data, n, [f64]q[n], n, [f64]p[n]);
	}

	:result f32;
	for(:i uint64 = 0; i < q.len; i++) {
		result += der_loss_q(q[i], p[i]);
	}
	result / [f32]q.len
}

function back(:net [][10]Neuron, :out [10]f32, :lbl [10]f32, :learning_rate f32) {
	// *** output layer ***
	{
		// ** calculate cost derivative with respect to weights **
		:loss_derivative f32 = der_cost_q(out, lbl);
		:update f32 = loss_derivative * learning_rate;

		// ** update weights ** 
		for(:n uint64 = net[1].len-1; n >= 0; n--) {
			for(:w uint64 = 0; w < net[1][n].weights.len; w++) {
				net[1][n].weights[w] -= update;
				printf("%f\n".data, [f64]net[1][n].weights[w]);
			}
		}
	};

	// *** input layer ***

}

function main() {
	:images [][28][28]uint8 = read_dataset_image("./examples/softmax_mcnn/train-images-idx3-ubyte");
	:labels []     uint8 = read_dataset_label("./examples/softmax_mcnn/train-labels-idx1-ubyte");
	
	printf("%llx\n".data, images.len);

	// cast image set to f32
	:image_set [][784]f32 = allocate(28*28*images.len*4);
	for(:i uint32 = 0; i < [uint32]image_set.len; i++) {
		for(:r uint32 = 0; r < 28; r++) {
			for(:c uint32 = 0; c < 28; c++) {
				:pixel uint8 = images[i][r][c];
				if pixel > 0 {
					image_set[i][r * 28 + c] = 1.0 / [f32]pixel;
				}
			}
		}
	}
	
	// cast label set to binary vector (still f32 because math)
	:label_set [][10]f32 = allocate(labels.len*4*10);
	for(:i uint32 = 0; i < [uint32]label_set.len; i++) {
		:answer uint8 = labels[i];
		label_set[i][answer] = 1.0;	
	}

	
	:neural_network [][10]Neuron = nn();
	printf("neural_network.len: %d\n".data, neural_network.len);

	// write ones in weights
	for(:l int32 = 0; l < [int32]neural_network.len; l++) {
		for(:i int32 = 0; i < [int32]neural_network[l].len; i++) {
			for(:j int32 = 0; j < [int32]neural_network[l][i].weights.len; j++) {
				neural_network[l][i].weights[j] = 1.0;
			}
			neural_network[l][i].bias = 1.0;
		}
	}
		
	:probability_distribution [10]f32 = forward(neural_network, image_set[5]);
	for(:n int32 = 0; n < [int32]probability_distribution.len; n++) {
		printf("probability[%u]: %f; label[%u]: %f\n".data, n, [f64]probability_distribution[n], n, [f64]label_set[5][n]);
	}
	printf("cost: %f\n".data, [f64]cost(probability_distribution, label_set[5]));

	back(neural_network, probability_distribution, label_set[5], 0.1);

	return;
	
	
	/*
	for(:i int32 = 0; i < [int32]neural_network.len; i++) {
		for(:j int32 = 0; j < [int32]neural_network[i].len; j++) {
			:w []f32 = neural_network[i][j].weights;
			:b f32 = neural_network[i][j].bias;
	
			for(:k int32 = 0; k < [int32](w.len); k++) {
				printf("neuron[%d][%d].weights[%d]: %u\n".data, i, j, k, w[k]);
			}
			printf("neuron[%d][%d].bias: %u\n".data, i, j, b);
		}
	}
	

	for(:i uint32 = 0; i < [uint32]images.len; i++) {
		printf("label: %hhu\n".data, labels[i]);
		for(:r uint32 = 0; r < 28; r++) {
			for(:c uint32 = 0; c < 28; c++) {
				:image uint32 = i;
				:p uint8 = [uint8]image_set[image][r * 28 + c];
	
				if p > 5 {
					putchar('@');
				} else {
					putchar(' ');
				}
			}
			putchar('\n');
		}
	}
*/
}
