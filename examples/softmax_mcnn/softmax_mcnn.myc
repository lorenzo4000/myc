/*
	we rapresent numbers as binary vector of size 10 (0-9)
	the image is big 256x256 grey-scale pixels, so...
	
		first layer has 10 neurons with how many weights?
		28*28 = 784 weights
	

*/

@import "lib/c/stdio.myc"
@import "lib/memory.myc"

//  ssize_t read(int fd, void *buf, size_t count);
function read(:fd int32, :buf *?, :count uint64) uint64 external;

// int open(const char *pathname, int flags, mode_t mode);
function open(:pathname *uint8, :flags int32, :mode uint32) int32 external;

function flip32(:x uint32) uint32{
	:flipped uint32 = 0;
	
	flipped |= (x & (0xFF << 0 )) << 24;
	flipped |= (x & (0xFF << 8 )) << 8 ;
	flipped |= (x & (0xFF << 16)) >> 8 ;
	flipped |= (x & (0xFF << 24)) >> 24;

	return flipped;
}

function read_dataset_image(:filename string) [][784]uint8 {
	// open file read-only
	:fd int32 = open(filename.data, 0, 0);
	if fd < 0 {
		printf("error: could not opend file `%s`!".data, filename.data);
		return;
	}

	// magic value
	:magic_value uint32;
	:n uint64 = read(fd, &magic_value, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	magic_value = flip32(magic_value);
	printf("magic number: %x\n".data, magic_value);

	// number of images
	:number_of_images uint32;
	n = read(fd, &number_of_images, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	number_of_images = flip32(number_of_images);
	printf("number of images in set: %d\n".data, number_of_images);

	// number of rows
	:number_of_rows uint32;
	n = read(fd, &number_of_rows, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	number_of_rows = flip32(number_of_rows);
	printf("number of rows in set: %d\n".data, number_of_rows);
	
	// number of columns
	:number_of_columns uint32;
	n = read(fd, &number_of_columns, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	number_of_columns = flip32(number_of_columns);
	printf("number of columns in set: %d\n".data, number_of_columns);

	:number_of_pixels uint32 = number_of_images * number_of_rows * number_of_columns;
	printf("number of pixels in set: %d\n".data, number_of_pixels);

	:images [][784]uint8 = allocate([uint64]number_of_pixels);
	for(:i uint32 = 0; i < number_of_images; i++) {
		n = read(fd, images[i].data, ([uint64]number_of_rows * [uint64]number_of_columns));
		if n < ([uint64]number_of_rows * [uint64]number_of_columns) {
			printf("error: could not read file in memory!\n".data);
			return;
		}
	}
	
	return images;
}

function read_dataset_label(:filename string) []uint8 {
	// open file read-only
	:fd int32 = open(filename.data, 0, 0);
	if fd < 0 {
		printf("error: could not opend file `%s`!".data, filename.data);
		return;
	}

	// magic value
	:magic_value uint32;
	:n uint64 = read(fd, &magic_value, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	magic_value = flip32(magic_value);
	printf("magic number: %x\n".data, magic_value);

	// number of labels
	:number_of_labels uint32;
	n = read(fd, &number_of_labels, 4);
	if n < 4 {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	number_of_labels = flip32(number_of_labels);
	printf("number of labels in set: %d\n".data, number_of_labels);

	:labels []uint8 = allocate([uint64]number_of_labels);
	n = read(fd, labels.data, [uint64]number_of_labels);
	if n < [uint64]number_of_labels {
		printf("error: could not read file in memory!\n".data);
		return;
	}
	
	return labels;
}

function matmul(:a [][]uint32, :b [][]uint32) [][]uint32 {
	:ah uint64 = a.len;
	if ah <= 0 {
		return;
	}
	:aw uint64 = a[0].len;
	if aw <= 0 {
		return;
	}
	
	:bh uint64 = b.len;
	if bh <= 0 {
		return;
	}
	:bw uint64 = b[0].len;
	if bw <= 0 {
		return;
	}

	if aw != bh {
		return;
	}

	:c [][]uint32 = allocate(ah * bw * 4);

	for(:i int32 = 0; i < [int32]ah; i++) {
		for(:j int32 = 0; j < [int32]aw; j++) {
			for(:k int32 = 0; k < [int32]aw; k++) {
				c[i][j] += a[i][k] * b[k][j];
			}
		}
	}

	return c;
} 

struct Neuron {
	:weights [784]uint32;
	:bias 		  uint32;
}

function nn(:levels uint32) [][10]Neuron {
	:network [][10]Neuron = allocate([uint64]levels * 10 * 785 * 4);

	return network;
}

function forward(:net [][10]Neuron, :x [748]uint8) {
	:first_layer [10]Neuron = net[0];
	:first_layer_out [10]uint32;

	//for(:n int32 = 0; n < [int32]first_layer.len; n++) {
	//}
	
}

function main() {
	:image_set [][784]uint8 = read_dataset_image("./examples/softmax_mcnn/train-images-idx3-ubyte");
	:label_set []     uint8 = read_dataset_label("./examples/softmax_mcnn/train-labels-idx1-ubyte");

	printf("%lld\n".data, image_set.len);

	:neural_network [][10]Neuron = nn(1);
	
	/*
	for(:i int32 = 0; i < [int32]neural_network.len; i++) {
		for(:j int32 = 0; j < [int32]neural_network[i].len; j++) {
			:w []uint32 = neural_network[i][j].weights;
			:b uint32 = neural_network[i][j].bias;

			for(:k int32 = 0; k < [int32](w.len); k++) {
				printf("neuron[%d][%d].weights[%d]: %u\n".data, i, j, k, w[k]);
			}
			printf("neuron[%d][%d].bias: %u\n".data, i, j, b);
		}
	}
	*/

	/*	
	for(:i uint32 = 0; i < [uint32]image_set.len; i++) {
		printf("label: %hhu\n".data, label_set[i]);
		for(:r uint32 = 0; r < 28; r++) {
			for(:c uint32 = 0; c < 28; c++) {
				:image uint32 = i;
				:pixel uint32 = (r*28) + c;

				:p uint8 = image_set[image][pixel];

				if p > 5 {
					putchar('@');
				} else {
					putchar(' ');
				}
			}
			putchar('\n');
		}
	}
	*/
}
